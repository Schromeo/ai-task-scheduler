# ---------------------------------------------------
# 1. 基础配置
# ---------------------------------------------------
# 给我们的服务起个名字
spring.application.name=gateway
# 我们的服务在 8080 端口运行 (这是 Spring Boot 默认的)
server.port=8080

# ---------------------------------------------------
# 2. Kafka 配置
# ---------------------------------------------------
# 告诉 Spring Kafka, 我们的 "Kafka 经纪人" 在哪里
# 这就是我们 docker-compose.yaml 里暴露的 9092 端口
spring.kafka.bootstrap-servers=localhost:9092

# ---------------------------------------------------
# 3. MySQL (DataSource) 配置
# ---------------------------------------------------
# 数据库的 "连接字符串" (JDBC URL)
# 注意：我们连接的是在 docker-compose 里创建的 'task_scheduler' 数据库
spring.datasource.url=jdbc:mysql://localhost:3306/task_scheduler?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC

# (重点!) 我们使用“占位符”来读取机密信息
# 我们绝不会把 'user' 'password' 这种明文写死在这里
# 我们稍后会告诉 VS Code 如何在"运行时"注入这些值
spring.datasource.username=${DB_USER:user}
spring.datasource.password=${DB_PASS:password}

# ---------------------------------------------------
# 4. JPA (数据库 ORM) 配置
# ---------------------------------------------------
# 这是 JPA 的“大招”：
# "update" 模式会“自动”帮我们检查代码中的 @Entity (实体类)
# 并在数据库中“自动”创建或更新对应的表结构。
# 这在开发阶段简直是“神器”！
spring.jpa.hibernate.ddl-auto=update


# 在控制台打印出 JPA 正在执行的 SQL 语句
# (这对调试非常有用！)
spring.jpa.show-sql=true
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect
